# -*- coding: utf-8 -*-
"""Simple Project for Predict Best Move on Chess.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19a560FhXhH_9dN_15eGnGaTLlC5F6niB

#Install Python-Chess For Board and Pieces Visualitazion
"""

!pip install python-chess

"""#Test Membuat Model Komputer untuk Catur"""

!pip install python-chess

import chess
import chess.pgn
import numpy as np
import tensorflow as tf
import zstandard as zstd

# Fungsi untuk mendekompresi file PGN.zst
def decompress_pgn_zst(zst_file, output_file):
    with open(zst_file, 'rb') as compressed_file:
        dctx = zstd.ZstdDecompressor()
        with open(output_file, 'wb') as decompressed_file:
            decompressed_file.write(dctx.decompress(compressed_file.read()))

# Fungsi untuk memuat data dari file PGN
def load_pgn_data(pgn_file, max_games=1000):
    fen_list = []
    moves = []
    with open(pgn_file, 'r', encoding='utf-8', errors='ignore') as file: # Added encoding and errors arguments
        game_count = 0
        while game_count < max_games:
            game = chess.pgn.read_game(file)
            if game is None:
                print("No more games found in the file.") # Debugging print statement
                break # exit the loop if no more games are found in the file

            board = game.board()
            for move in game.mainline_moves():
                fen_list.append(board.fen())
                moves.append(move.uci())
                board.push(move)

            game_count += 1
            print(f"Game {game_count} loaded.") # Print statement to track game loading

    return fen_list, moves

# Fungsi untuk mengonversi posisi papan (FEN) ke array numerik
def fen_to_array(fen):
    board = chess.Board(fen)
    piece_map = board.piece_map()

    # Representasi papan 8x8
    board_array = np.zeros((8, 8), dtype=int)
    for square, piece in piece_map.items():
        row, col = divmod(square, 8)
        board_array[row][col] = piece.piece_type if piece.color == chess.WHITE else -piece.piece_type

    # Tambahkan fitur tambahan
    features = []
    features.append(1 if board.turn == chess.WHITE else 0)  # Giliran
    features.append(board.has_kingside_castling_rights(chess.WHITE))  # Castling putih (kingside)
    features.append(board.has_queenside_castling_rights(chess.WHITE))  # Castling putih (queenside)
    features.append(board.has_kingside_castling_rights(chess.BLACK))  # Castling hitam (kingside)
    features.append(board.has_queenside_castling_rights(chess.BLACK))  # Castling hitam (queenside)

    return np.concatenate((board_array.flatten(), features))

# Fungsi untuk mengonversi langkah ke one-hot encoding
def moves_to_one_hot(moves, move_to_index):
    num_moves = len(moves)
    num_classes = len(move_to_index)
    one_hot = np.zeros((num_moves, num_classes), dtype=int)
    for i, move in enumerate(moves):
        if move in move_to_index:
            one_hot[i, move_to_index[move]] = 1
    return one_hot

def create_model(input_shape, output_shape):
    model = tf.keras.Sequential([
        tf.keras.layers.Dense(128, activation='relu', input_shape=(input_shape,)),
        tf.keras.layers.Dropout(0.2),  # Add a dropout layer
        tf.keras.layers.Dense(64, activation='relu'),
        tf.keras.layers.Dropout(0.2),  # Add another dropout layer
        tf.keras.layers.Dense(output_shape, activation='softmax')
    ])
    model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])
    return model

# Dekompresi file PGN.zst
#zst_file = "/content/lichess_db_standard_rated_2013-06.pgn.zst"
pgn_file = "/content/lichess_db_standard_rated_2013-06.pgn"
#decompress_pgn_zst(zst_file, pgn_file)

# Muat data dari file PGN
fen_list, moves = load_pgn_data(pgn_file, max_games=2500)

# Buat kamus langkah ke indeks
unique_moves = sorted(set(moves))
move_to_index = {move: idx for idx, move in enumerate(unique_moves)}

# Konversi data ke format yang dapat digunakan oleh model
X = np.array([fen_to_array(fen) for fen in fen_list])
Y = moves_to_one_hot(moves, move_to_index)

# Buat dan latih model
model = create_model(X.shape[1], Y.shape[1])
model.fit(X, Y, epochs=10, batch_size=32)

# Simpan model yang sudah dilatih
model.save("chess_model.h5")
print("Model telah disimpan sebagai chess_model.h5")

"""PROGRAM BERMAIN CATUR SEDERHANA"""

import chess
import numpy as np
import random

# Fungsi untuk mengonversi posisi papan (FEN) ke array numerik
def fen_to_array(fen):
    board = chess.Board(fen)
    piece_map = board.piece_map()

    # Representasi papan 8x8
    board_array = np.zeros((8, 8), dtype=int)
    for square, piece in piece_map.items():
        row, col = divmod(square, 8)
        board_array[row][col] = piece.piece_type if piece.color == chess.WHITE else -piece.piece_type

    # Tambahkan fitur tambahan
    features = []
    features.append(1 if board.turn == chess.WHITE else 0)  # Giliran
    features.append(board.has_kingside_castling_rights(chess.WHITE))  # Castling putih (kingside)
    features.append(board.has_queenside_castling_rights(chess.WHITE))  # Castling putih (queenside)
    features.append(board.has_kingside_castling_rights(chess.BLACK))  # Castling hitam (kingside)
    features.append(board.has_queenside_castling_rights(chess.BLACK))  # Castling hitam (queenside)

    return np.concatenate((board_array.flatten(), features))

# Fungsi untuk memprediksi langkah terbaik menggunakan model
import numpy as np

def get_best_move(board, model, move_to_index):
    fen = board.fen()
    position = fen_to_array(fen).reshape(1, -1)  # Convert to a single input

    legal_moves = list(board.legal_moves)
    if not legal_moves:
        return None

    legal_moves_uci = [move.uci() for move in legal_moves]
    legal_move_indices = [move_to_index[move_uci] for move_uci in legal_moves_uci if move_uci in move_to_index]

    if not legal_move_indices:
        return random.choice(legal_moves_uci)  # Choose random move if no legal moves found

    if not legal_move_scores:
        # Check for castling legality before making the move
        if board.is_castling("e1g1") and "0-0" in move_to_index:  # Kingside castling
            return "0-0"
        elif board.is_castling("e1c1") and "0-0-0" in move_to_index: # Queenside castling
            return "0-0-0"
        else:
            return random.choice(legal_moves_uci)

    # Perform a single batch prediction for all legal moves
    predictions = model.predict(np.repeat(position, len(legal_move_indices), axis=0), verbose=0)

    # Extract predictions for legal moves and find the best move
    legal_move_scores = [(legal_moves_uci[i], predictions[i, legal_move_indices[i]]) for i in range(len(legal_move_indices))]
    best_move_uci, _ = max(legal_move_scores, key=lambda item: item[1])

    return best_move_uci

def evaluate_material_change(board):
    """
    Evaluates the material change from the perspective of the current player.
    Positive value indicates material gain, negative indicates loss.
    """
    score = 0
    for square in chess.SQUARES:
        piece = board.piece_at(square)
        if piece:
            value = PIECE_VALUES.get(piece.piece_type, 0)
            if piece.color == board.turn:
                score += value
            else:
                score -= value
    return score

# Assuming you have PIECE_VALUES defined somewhere in your code (e.g., at the top)
PIECE_VALUES = {
    chess.PAWN: 1,
    chess.KNIGHT: 3,
    chess.BISHOP: 3,
    chess.ROOK: 5,
    chess.QUEEN: 9,
    chess.KING: 0  # Nilai raja tidak dihitung karena raja tidak boleh dimakan
}

# Fungsi untuk mencetak papan catur dengan koordinat
def print_board_with_coordinates(board):
    board_str = str(board)  # Mengambil representasi papan standar dari library chess
    rows = board_str.split("\n")  # Memisahkan papan menjadi baris
    print("\n  a b c d e f g h")  # Header kolom
    for i, row in enumerate(rows):
        print(f"{8 - i} {row} {8 - i}")  # Tambahkan indeks baris di kiri dan kanan
    print("  a b c d e f g h")  # Footer kolom

# Fungsi utama permainan
def play_chess(model, move_to_index):
    board = chess.Board()
    print("Selamat datang di permainan catur!")
    print("Masukkan langkah Anda dalam notasi UCI (contoh: e2e4).")

    while not board.is_game_over():
        # Cetak papan dengan koordinat
        print("\nPapan Catur:")
        print_board_with_coordinates(board)

        # Input langkah pemain
        try:
            player_move = input("\nLangkah Selanjutnya: ")
            board.push_uci(player_move)  # Jalankan langkah pemain
        except Exception as e:
            print("Langkah tidak valid. Coba lagi.")
            continue

        if board.is_game_over():
            break

        # Langkah komputer
        print("\nKomputer sedang berpikir...")
        computer_move_uci = get_best_move(board, model, move_to_index)
        if computer_move_uci is not None:
            board.push_uci(computer_move_uci)  # Run the computer's move
            print(f"Komputer melangkah: {computer_move_uci}")
        else:
            print("No legal moves available for the computer. Game over.")
            break

    # Hasil akhir permainan
    print("\nPapan Akhir:")
    print_board_with_coordinates(board)
    if board.is_checkmate():
        print("Skakmat!")
    elif board.is_stalemate():
        print("Stalemate!")
    elif board.is_insufficient_material():
        print("Hasil imbang karena material tidak mencukupi!")
    else:
        print("Permainan selesai!")

# Muat model yang sudah dilatih
print("Memuat model...")
from tensorflow.keras.models import load_model
model = load_model("chess_model.h5")  # Ganti dengan path model Anda


# Buat kamus langkah ke indeks dengan SEMUA langkah UCI yang valid
all_possible_moves = []
board = chess.Board()  # Create a new board
for move in chess.LegalMoveGenerator(board):
    all_possible_moves.append(move.uci())

# Add castling moves explicitly
all_possible_moves.extend(["0-0", "0-0-0"])
# Create the move_to_index dictionary
move_to_index = {move: idx for idx, move in enumerate(all_possible_moves)}


# Jalankan permainan
play_chess(model, move_to_index)